6-1 intro
顺序程序设计
内部顺序性：每个程序在处理器上执行严格有序
外部顺序性：把一个具体问题的求解过程设计成一个程序或严格顺序执行的程序序列
 
顺序程序设计的特性：
程序设计的顺序性
计算环境的封闭性
计算结果的确定性
计算过程的可再现性
 
 
 
 
 
并发程序设计：把一个具体问题求解设计成若干可同时执行的程序模块的方法
特性：
并行性：多个进程在多道程序系统中并发执行，或在多处理器系统中并行执行
共享性：多个进程共享软件资源
交往性：多个进程并发执行时存在制约
 
6-2 并发进程的制约关系
无关的并发进程：一组并发进程分别在不同的变量集合上运行，一个进程的执行与其他并发进程的进展无关
 
交往的并发进程：一组并发进程共享某些变量，一个进程的执行可能影响其他并发进程的结果
执行的相对速度无法控制，可能发生与时间有关的错误：
1 结果错误
 
 
2 永远等待
 
 
在进入if条件之后，主存资源被全部释放，进入等待队列的进程会永远等待
 
并发进程的制约关系：
1 进程互斥：并发进程之间因相互争夺独占性资源而产生的竞争制约关系
e.g. 同时读取机票数共享变量
2 进程同步：并发进程之间为完成共同任务来协调执行先后关系而产生的协作制约关系
e.g. 在输入过程结束后才可以进行计算
 
6-3 临界区
临界资源：互斥共享变量所代表的资源，即一次只能被一个进程所使用的资源
临界区：与互斥共享变量相关的程序段
 
如果多个进程同时停留在相关的临界区内，就会出现与时间相关的错误
两个进程临界区由相同的临界资源，就是相关的临界区，必须互斥进入；否则没有限制
 
临界区管理的要求：
1 一次至多允许一个进程停留在相关的临界区
2 一个进程不能无限制留在临界区
3 一个进程不能无限制等待进入临界区
 
临界区的嵌套使用
 
进程1进入x相关的临界区中断，则进程2无法进入与x相关的临界区，造成死锁
因此，要将每个临界区分级，进行拓扑排序，按照顺序进行嵌套
 
6-4  临界区管理
 
 
进程1首先执行，测试进程2是否在临界区
进程2不在临界区
进程1通过测试，在挂锁前中断
进程2执行，测试进程1是否在临界区
进程1不在临界区
进程2通过测试，挂锁，进入临界区，中断
进程1进入临界区，进程2同时恢复中断，gg
 
 
 
进程1挂锁，中断
进程2挂锁，测试进程1是否在临界区
进程1在临界区
进程1恢复中断，测试进程2是否在临界区
进程2在临界区
死锁，gg
 
解决思路：
 
 
用一条指令同时完成测试锁和建立锁：测试并建立指令（CPU完成一条指令时不会中断）
 
1 测试并建立指令
 
 
2 对换指令
 
 
若lock == false, pi 和 lock对换，进入临界区且上锁
否则，pi == lock == true，无法进入临界区
 
问题：在进入临界区前忙式等待，占用CPU，效率低
解决：关中断，进临界区，开中断
操作系统访问硬件资源采用的方式，不建议用户程序使用该方法进行临界区管理
 
6-6 pv操作与进程互斥
信号量
一种可动态定义的软件资源
核心数据结构：等待进程队列
信号量声明：资源报道，建立队列
申请资源的原语：若申请不得，调用进程入队等待
归还资源的原语：若队列中有等待进程，需释放
信号量撤销：资源注销，撤销队列
 
记录型信号量
 
 
*List 等待进程队列
Value > 0 : 资源可复用次数
Value = 0 : 无资源且无等待进程
Value < 0 : 等待队列中进程个数
 
 
 
 
 
e.g. 机票问题
 
 
问题：不同航班的临界区并不相关
优化：设置m个信号量
 
 
6-7 pv操作与进程同步
1 一个生产者一个消费者共享一个缓冲区：
 
 
同步关系1：消费者一开始等待产品，设置第一个信号量，初值为0（没有产品）
同步关系2：生产者在等待缓冲区空位，设置第二个信号量，初值为1（有空位）
 
 
P(sput) {
  while (sput == 0)
  sput--
}
 
V(sget) {
  while (sget == 1)
  sget++
}
 
P(sget) {
  while (sget == 0)
  sget--
}
 
V(sput) {
  while (sput == 1)
  sput++
}
 
2 一个生产者一个消费者共享多个缓冲区
 
 
3 多个生产者多个消费者共享多个缓冲区
 
 
6-9 管程
用类的概念把对共享变量的访问封装起来
由若干公共变量及访问这些变量的过程组成
进程只能互斥地调用管程中的过程（与类不同）
 
 
 
（霍尔管程，看不懂）
 
6-12 进程通信
1 进程直接通信
发送或接收信件的进程指出信件发给谁或从谁那里接收信件
 
2 进程间接通信
发送或者接收信件通过一个信箱来进行，多个进程共享一个信箱
send（a, 信件）：把信件传送到信箱a
receive（a，信件）：从信箱a接收信件
 
6-13 高级进程的通信机制
1 基于流的进程通信
多个进程使用一个共享的消息缓冲区
一些进程往缓冲区写入字符流
一些进程从缓冲区读入字符流
 
2 远程过程调用rpc
采用客户/服务器计算模式
服务器进程提供一系列过程/服务，供客户进程调用
客户进程通过调用服务器服务进程的过程/服务，获得服务
基于分布式系统的并发程序设计
 
6-14 死锁
死锁的产生：
多个进程并发时，系统必须提供同步机制和进程通信机制
若机制不当，可能会产生死锁
 
死锁的定义：
每一个进程都在等待被另一个进程所占有的、不能抢占的资源
存在n个进程p1,p2,…,pn，n个资源r1,r2,…,rn
进程pi因为申请不到资源ri而处于等待状态
而ri被pi+1占有,rn被p1占有
这n个进程的等待状态永远不能结束，即处于死锁状态
 
E.g.
 
 
 
 
 
 
死锁产生的必要条件：
1 进程独占资源
2 进程等待时不放弃已有资源
3 进程不能抢夺资源
4 进程循环等待
四个条件缺一不可
 
解决死锁的方法：
1 死锁防止
破坏某个必要条件（一一对应）
（1）把独占型资源改造成共享性资源
E.g. 打印机
（2）预分配
进程必须在执行前就得到所有需要的资源，在执行中不申请任何资源
（3）剥夺式调度方法
E.g. 对主存资源和处理器资源的分配
（4）层次分配
把资源分成多个层次
进程得到某一层的资源后，只能申请同层或较高层的资源
且申请同层资源前，必须先释放同层中的资源
进程释放某一层的资源前，必须先释放较高层的资源
不会形成回路，层次低的资源使用效率高
 
2 死锁避免
当不能防止死锁产生时，掌握资源申请情况，避免死锁
在为进程分配资源前，先测试是否会产生死锁，若会产生，则拒绝分配
 
银行家算法：借钱给有偿还能力的客户
仅仅在申请者可以无条件归还所申请的全部资源，才给他分配所申请的资源
要根据所有进程的状态来判断：其他进程以后是否能拿到所需资源，能否归还资源
 
 
 
（1）若给q分配2个资源
q拿到2个资源，完成进程，释放4个资源
p拿到4个资源，完成进程，释放8个资源
r拿到7个资源，完成进程，释放9个资源
P,q,r进程都结束，可以对q分配2个资源
 
（2）若给p分配2个资源
p拿到2个资源，继续等待2个资源，同时q和r都在等待资源，而可分配的资源为0
产生死锁，不能对p分配2个资源
 
（3）若给r分配2个资源
r拿到2个资源，继续等待5个资源，同时p和q都在等待资源，而可分配的资源为0
产生死锁，不能对r分配2个资源
 
3 死锁检测和恢复
系统定时运行死锁检测程序，发现死锁时解除死锁
设置等待资源表和占用资源表，检测程序反复检测，列出等待占用关系
 
等待占用关系：若进程pi等待某资源，且该资源被pj占用，记为w(pi,pj)
等待占用关系可以看作一个有向图，若出现w(pi,pj),w(pj,pk),…,w(pm,pi)，即图中有环，则出现死锁
 
检测死锁《=》检测图中是否有环
 
(1) dfs + color
Runtime: o(v + e)
Space: o(v + e)
 
(2) warshall
Runtime: o(v3)
Space: o(v2)
把等待占用关系用邻接矩阵表示：
 
 
public bool[][] GetMatrix()
 58
 
            {
 59
 
                for (int i = 0; i < _matrix.Length; i++)
 60
 
                {
 61
 
                    for (int x = 0; x < _matrix.Length; x++)
 62
 
                    {
 63
 
                        if (x == i)
 64
 
                        {
 65
 
                            continue;
 66
 
                        }
 67
 
 68
 
                        for (int y = 0; y < _matrix.Length; y++)
 69
 
                        {
 70
 
                            if (y == i)
 71
 
                            {
 72
 
                                continue;
 73
 
                            }
 74
 
 75
 
                            if (_matrix[x][i] && _matrix[i][y])
 76
 
                            {
 77
 
                                _matrix[x][y] = true;
 78
 
                            }
 79
 
                        }
 80
 
                    }
 81
 
                }
 82
 
 83
 
 84
 
                return _matrix;
 85
 
            }
 
若_matrix上对角线出现1，则有环
 
检测到死锁后的解决办法：
1 从头开始
2 定时设置校验点，从校验点起重新执行
3 中断某个卷入死锁的进程后，重新执行

